%%
% Copyright (c) 2017 - 2019, Pascal Wagler;  
% Copyright (c) 2014 - 2019, John MacFarlane
% 
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without 
% modification, are permitted provided that the following conditions 
% are met:
% 
% - Redistributions of source code must retain the above copyright 
% notice, this list of conditions and the following disclaimer.
% 
% - Redistributions in binary form must reproduce the above copyright 
% notice, this list of conditions and the following disclaimer in the 
% documentation and/or other materials provided with the distribution.
% 
% - Neither the name of John MacFarlane nor the names of other 
% contributors may be used to endorse or promote products derived 
% from this software without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
% "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
% LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
% FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
% COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
% INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
% BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
% LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
% CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
% LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
% ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
% POSSIBILITY OF SUCH DAMAGE.
%%

%%
% This is the Eisvogel pandoc LaTeX template.
%
% For usage information and examples visit the official GitHub page:
% https://github.com/Wandmalfarbe/pandoc-latex-template
%%

\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*,table}{xcolor}
%
\documentclass[
  spanish,
  a4paper,
,tablecaptionabove
]{scrartcl}
\usepackage{lmodern}
\usepackage{setspace}
\setstretch{1.2}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\definecolor{default-linkcolor}{HTML}{A50000}
\definecolor{default-filecolor}{HTML}{A50000}
\definecolor{default-citecolor}{HTML}{4077C0}
\definecolor{default-urlcolor}{HTML}{4077C0}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Informe Tarea 2},
  pdfauthor={Vicente Reyes},
  pdfsubject={Java},
  pdfkeywords={Backtracking, Recursión},
  pdfborder={0 0 0},
  breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=2.5cm,includehead=true,includefoot=true,centering]{geometry}
\usepackage{listings}
\newcommand{\passthrough}[1]{#1}
\lstset{defaultdialect=[5.3]Lua}
\lstset{defaultdialect=[x86masm]Assembler}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% Make use of float-package and set default placement for figures to H
\usepackage{float}
\floatplacement{figure}{H}

\ifnum 0\ifxetex 1\fi=0 % if pdftex or luatex
  \usepackage[shorthands=off,main=spanish]{babel}
\else % if xetex
    % See issue https://github.com/reutenauer/polyglossia/issues/127
  \renewcommand*\familydefault{\sfdefault}
    % load polyglossia as late as possible as it *could* call bidi if RTL lang (e.g. Hebrew or Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[]{spanish}
\fi

\title{Informe Tarea 2}
\author{Vicente Reyes}
\date{2019-04-08}





%%
%% added
%%

%
% language specification
%
% If no language is specified, use English as the default main document language.
%


%
% for the background color of the title page
%
\usepackage{pagecolor}
\usepackage{afterpage}

%
% TOC depth and 
% section numbering depth
%
\setcounter{tocdepth}{3}

%
% break urls
%
\PassOptionsToPackage{hyphens}{url}

%
% When using babel or polyglossia with biblatex, loading csquotes is recommended 
% to ensure that quoted texts are typeset according to the rules of your main language.
%
\usepackage{csquotes}

%
% captions
%
\definecolor{caption-color}{HTML}{777777}
\usepackage[font={stretch=1.2}, textfont={color=caption-color}, position=top, skip=4mm, labelfont=bf, singlelinecheck=false, justification=raggedright]{caption}
\setcapindent{0em}

%
% blockquote
%
\definecolor{blockquote-border}{RGB}{221,221,221}
\definecolor{blockquote-text}{RGB}{119,119,119}
\usepackage{mdframed}
\newmdenv[rightline=false,bottomline=false,topline=false,linewidth=3pt,linecolor=blockquote-border,skipabove=\parskip]{customblockquote}
\renewenvironment{quote}{\begin{customblockquote}\list{}{\rightmargin=0em\leftmargin=0em}%
\item\relax\color{blockquote-text}\ignorespaces}{\unskip\unskip\endlist\end{customblockquote}}

%
% Source Sans Pro as the de­fault font fam­ily
% Source Code Pro for monospace text
%
% 'default' option sets the default 
% font family to Source Sans Pro, not \sfdefault.
%
\usepackage[default]{sourcesanspro}
\usepackage{sourcecodepro}

% XeLaTeX specific adjustments for straight quotes: https://tex.stackexchange.com/a/354887
% This issue is already fixed (see https://github.com/silkeh/latex-sourcecodepro/pull/5) but the 
% fix is still unreleased.
% TODO: Remove this workaround when the new version of sourcecodepro is released on CTAN.
\ifxetex
\makeatletter
\defaultfontfeatures[\ttfamily]
  { Numbers   = \sourcecodepro@figurestyle,
    Scale     = \SourceCodePro@scale,
    Extension = .otf }
\setmonofont
  [ UprightFont    = *-\sourcecodepro@regstyle,
    ItalicFont     = *-\sourcecodepro@regstyle It,
    BoldFont       = *-\sourcecodepro@boldstyle,
    BoldItalicFont = *-\sourcecodepro@boldstyle It ]
  {SourceCodePro}
\makeatother
\fi

%
% heading color
%
\definecolor{heading-color}{RGB}{40,40,40}
\addtokomafont{section}{\color{heading-color}}
% When using the classes report, scrreprt, book, 
% scrbook or memoir, uncomment the following line.
%\addtokomafont{chapter}{\color{heading-color}}

%
% variables for title and author
%
\usepackage{titling}
\title{Informe Tarea 2}
\author{Vicente Reyes}

%
% tables
%

%
% remove paragraph indention
%
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines

%
%
% Listings
%
%


%
% listing colors
%
\definecolor{listing-background}{HTML}{F7F7F7}
\definecolor{listing-rule}{HTML}{B3B2B3}
\definecolor{listing-numbers}{HTML}{B3B2B3}
\definecolor{listing-text-color}{HTML}{000000}
\definecolor{listing-keyword}{HTML}{435489}
\definecolor{listing-identifier}{HTML}{435489}
\definecolor{listing-string}{HTML}{00999A}
\definecolor{listing-comment}{HTML}{8E8E8E}
\definecolor{listing-javadoc-comment}{HTML}{006CA9}

\lstdefinestyle{eisvogel_listing_style}{
  language         = java,
  numbers          = left,
  xleftmargin      = 2.7em,
  framexleftmargin = 2.5em,
  backgroundcolor  = \color{listing-background},
  basicstyle       = \color{listing-text-color}\small\ttfamily{}\linespread{1.15}, % print whole listing small
  breaklines       = true,
  frame            = single,
  framesep         = 0.19em,
  rulecolor        = \color{listing-rule},
  frameround       = ffff,
  tabsize          = 4,
  numberstyle      = \color{listing-numbers},
  aboveskip        = -0.7em,
  belowskip        = 0.1em,
  abovecaptionskip = 0em,
  belowcaptionskip = 1em,
  keywordstyle     = \color{listing-keyword}\bfseries,
  classoffset      = 0,
  sensitive        = true,
  identifierstyle  = \color{listing-identifier},
  commentstyle     = \color{listing-comment},
  morecomment      = [s][\color{listing-javadoc-comment}]{/**}{*/},
  stringstyle      = \color{listing-string},
  showstringspaces = false,
  escapeinside     = {/*@}{@*/}, % Allow LaTeX inside these special comments
  literate         =
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\'e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\EUR}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
  {…}{{\ldots}}1 {≥}{{>=}}1 {≤}{{<=}}1 {„}{{\glqq}}1 {“}{{\grqq}}1
  {”}{{''}}1
}
\lstset{style=eisvogel_listing_style}

\lstdefinelanguage{XML}{
  morestring      = [b]",
  moredelim       = [s][\bfseries\color{listing-keyword}]{<}{\ },
  moredelim       = [s][\bfseries\color{listing-keyword}]{</}{>},
  moredelim       = [l][\bfseries\color{listing-keyword}]{/>},
  moredelim       = [l][\bfseries\color{listing-keyword}]{>},
  morecomment     = [s]{<?}{?>},
  morecomment     = [s]{<!--}{-->},
  commentstyle    = \color{listing-comment},
  stringstyle     = \color{listing-string},
  identifierstyle = \color{listing-identifier}
}

%
% header and footer
%
\usepackage{fancyhdr}

\fancypagestyle{eisvogel-header-footer}{
  \fancyhead{}
  \fancyfoot{}
  \lhead[2019-04-08]{Informe Tarea 2}
  \chead[]{}
  \rhead[Informe Tarea 2]{2019-04-08}
  \lfoot[\thepage]{Vicente Reyes}
  \cfoot[]{}
  \rfoot[Vicente Reyes]{\thepage}
  \renewcommand{\headrulewidth}{0.4pt}
  \renewcommand{\footrulewidth}{0.4pt}
}
\pagestyle{eisvogel-header-footer}

%%
%% end added
%%

\begin{document}

%%
%% begin titlepage
%%

\begin{titlepage}
\newgeometry{left=6cm}
\newcommand{\colorRule}[3][black]{\textcolor[HTML]{#1}{\rule{#2}{#3}}}
\begin{flushleft}
\noindent
\\[-1em]
\color[HTML]{5F5F5F}
\makebox[0pt][l]{\colorRule[435488]{1.3\textwidth}{4pt}}
\par
\noindent

{ \setstretch{1.4}
\vfill
\noindent {\huge \textbf{\textsf{Informe Tarea 2}}}
\vskip 2em
\noindent
{\Large \textsf{Vicente Reyes}
\vfill
}


\textsf{2019-04-08}}
\end{flushleft}
\end{titlepage}
\restoregeometry

%%
%% end titlepage
%%



\hypertarget{introducciuxf3n}{%
\section{Introducción}\label{introducciuxf3n}}

En esta tarea se pide escribir un programa solucionador de Sudokus. El
Sudoku debe ser leído de la entrada estándar, siguiendo un formato
detallado más adelante, y luego se deben imprimir: * El Sudoku
solucionado * La cantidad de casillas \enquote{fáciles} que fueron
rellenas (más detalles acerca de qué significa \enquote{fácil} más
adelante)

Esta tarea tiene el objetivo de aprender a usar los conceptos de
backtracking e invariante, y sentirse cómodo con la idea de programar
mutando una matriz de datos.

\hypertarget{implementaciuxf3n}{%
\section{Implementación}\label{implementaciuxf3n}}

Afortunadamente, los pasos a seguir están bastante claros en el PDF de
las instrucciones. Lo único que faltaba era implementar este diseño

\hypertarget{diseuxf1o-de-la-soluciuxf3n}{%
\subsection{Diseño de la solución}\label{diseuxf1o-de-la-soluciuxf3n}}

Directo del enunciado:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Leer el tablero desde la entrada estándar, éste consiste de 9 líneas,
  con 9 números separados por espacios (se recomienda usar la clase
  Scanner y su función readLine para esto) y guardarlo en una matriz de
  enteros (int{[}{]}{[}{]}). Los ceros representan casillas en blanco.
\item
  Crear otra matriz donde se indican los posibles candidatos para cada
  espacio (\passthrough{\lstinline!int[][][] candidatos!}, donde
  \passthrough{\lstinline!candidatos[i][j][valor]!} indica si
  \passthrough{\lstinline!valor!} puede ir en el espacio (i,j) o si ya
  está descartado).
\item
  Hacer una pasada por el tablero y para cada espacio que tenga un valor
  asignado, descartar el valor correspondiente en todas las casillas de
  su misma fila, columna y caja de 3x3.
\item
  Rellenar todos los espacios del tablero donde solo se pueda poner un
  número, y descartar el número asignado de la fila, columna y caja como
  en el paso 3.
\item
  Repetir el paso 3 hasta que ya no queden espacios donde solo hay un
  número posible.
\item
  Usando backtracking, ir rellenando todos los espacios vacíos, probando
  con cada candidato posible en cada espacio (es importante probar sólo
  con los candidatos posibles y no con todos los números del uno al
  nueve). Use una función recursiva para este paso.
\item
  Una vez completado el sudoku, imprimir en pantalla la solución, con el
  mismo formato con el que se recibió, nueve líneas con nueve números
  cada una. Luego imprima en pantalla otra línea indicando la cantidad
  de casillas rellenadas antes de entrar al paso de backtracking. (Ver
  sección de ejemplos de entrada y salida).
\end{enumerate}

\hypertarget{del-diseuxf1o-al-cuxf3digo}{%
\subsection{Del diseño al código}\label{del-diseuxf1o-al-cuxf3digo}}

Para resolver este problema se siguieron las instrucciones datas por el
enunciado de forma muy directa. Cada función llamada por main representa
un paso específico. Para dar un claro ejemplo, la función
\passthrough{\lstinline!discard\_when\_possible!} es el paso tres del
enunciado.

\_ \_

\begin{lstlisting}[language=Java]
public static void main(String[] args) {
        get_sudoku();
        int filled_before_backtracking = 0;
        while (true) {
                discard_when_possible();
                int just_filled = fill_cells();
                if (just_filled == 0) {
                        break;
                }
                filled_before_backtracking += just_filled;
        }
        backtracking(0);
        print_sudoku();
        System.out.println(filled_before_backtracking);
}
\end{lstlisting}

Cada una de las funciones que resuelven el Sudoku trabaja sobre dos
estructuras globales que guardan información sobre el proceso de
solucionado del Sudoku. Éstas son: * \passthrough{\lstinline!board!}:
Una matriz de enteros de 9×9 que representa el Sudoku, donde las
casillas que tienen un 0 están vacías. *
\passthrough{\lstinline!discarded!}: Una \enquote{matriz 3D} de
booleanos que guarda información sobre los candidatos posibles que
quedan para cada casilla. Se usan 10 booleanos en lugar de 9 para evitar
tener que restar 1 cada vez que se quiere comprobar un número. Es decir,
en lugar de tener que decir algo del estilo
\passthrough{\lstinline!discarded[i][j][board[i][j]-1] = true;!} basta
con decir
\passthrough{\lstinline!discarded[i][j][board[i][j]] = true;!}.

\_ \_

\begin{lstlisting}[language=Java]
static int board[][] = new int[9][9]; // first coordinate is row, second is column
static boolean discarded[][][] = new boolean[9][9][10]; // always skip the first one
\end{lstlisting}

La manera de leer el sudoku utilizada asume simplemente que en la
entrada habrá 81 números, correspondiendo a cada casilla del Sudoku, con
0 representando las casillas vacías. Esta implementación, pese a no usar
la función \passthrough{\lstinline!readline!} como era sugerido, es
simple, clara y logra su cometido incluso cuando los fines de línea no
funcionan al copiar y pegar.

\newpage
\_ \_

\begin{lstlisting}[language=Java]
static void get_sudoku() {
        Scanner sc = new Scanner(System.in);

        for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 9; j++) {
                        board[i][j] = sc.nextInt();
                }
        }
        sc.close();
}
\end{lstlisting}

En los pasos 3 y 4 de las instrucciones (que corresponden a las
funciones \passthrough{\lstinline!discard\_when\_possible!} y
\passthrough{\lstinline!fill\_cells!}) se utilizan loops a lo largo de
la matriz para encontrar casillas que pueden solucionarse. Una valiosa
invariante en \passthrough{\lstinline!discard\_when\_possible!} es que
si un número ya está definido (es distinto de 0 en
\passthrough{\lstinline!board!}) pero además tiene casillas descartadas,
es porque ya está hecho todo el trabajo que se puede hacer con respecto
a esa casilla, y por lo tanto no es necesario repetirlo (como dice el
comentario en el siguiente fragmento de código).

\_ \_

\begin{lstlisting}[language=Java]
if (num != 0 && !discarded[i][j][num]) { // don't repeat work
        discard_column(i, j, num);
        discard_row(i, j, num);
        discard_block(i, j, num);
}
\end{lstlisting}

El paso 6, el backtracking, toma como argumento el número de la primera
casilla que puede no haber sido trabajada todavía ya que así evita
buscar un lugar vacío desde el principio cada vez que se llama a la
función recursivamente.\footnote{Se usa un solo argumento en lugar de
  dos porque así aumentarlo es trivial en comparación con la
  alternativa, que sería revisar si se llegó al final de una fila para
  reiniciar ESE contador y aumentar el de las columnas A MENOS QUE se
  haya terminado el de las columnas también en cuyo caso termina el
  programa. La complejidad de este enfoque es claramente mayor, y por lo
  tanto se eligió el de aumentar un sólo número, del 0 al 81.}
Después de encontrar una casilla vacía, prueba con todos los números
(aunqué rápidamente descarta los que están marcados como descartados),
revisando rápidamente si no hay nuevos errores y llamando recursivamente
a la función. Si ninguna llamada recursiva retorna true, entonces se
devuelve la casilla a su estado vacío y se retorna false significando
que no se pudo solucionar.

\_ \_

\begin{lstlisting}[language=Java]
static boolean backtracking(int cur_index) {
    // first, find a cell to try to fill
    // each call to the function will be in charge of one cell
    while (cur_index < 9*9) {
        int row = cur_index/9;
        int column = cur_index%9;
        if (board[row][column] != 0) {
            cur_index++;
            continue;
        }
        for (int i = 1; i <= 9; i++) {
            if (discarded[row][column][i]) {
                continue;
            }
            board[row][column] = i;
            if (check(row, column) && backtracking(cur_index+1)) {
                return true;
            }
        }
        board[row][column] = 0;
        return false;
    }

    // couldn't find an empty cell => finished
    return true;
}
\end{lstlisting}

\hypertarget{resultados-y-conclusiones}{%
\section{Resultados y conclusiones}\label{resultados-y-conclusiones}}

Aunque en cantidad de líneas de código la solución es larga, escribirla
resulta ser simple si se hace de manera ordenada, probando que cada
nuevo paso funcione por separado antes de escribir el siguiente. Por
otro lado, existe un aspecto negativo de esta manera de trabajar, que es
que tiende a crear programas más largos, con funciones muy similares
entre ellas, ya que cuando una parte funciona bien, uno se siente reacio
a cambiarla para poder reutilizar una función en otro paso del problema.
Como resultado, el programa tiene funciones que claramente hacen
trabajos muy similares (por ejemplo, la mayoría de las líneas de algo
fueron copiadas de origen).

Hablando sobre las técnicas particulares de programación utilizadas,
podemos concluir que el backtracking es una técnica muy poderosa y no
necesariamente ineficiente, sobre todo cuando es complementada por
técnicas no recursivas que restringen las posibilidades.

Notemos que este programa solo funciona para Sudokus válidos, ya que: 1.
\passthrough{\lstinline!main!} ni siquiera revisa el valor retornado por
\passthrough{\lstinline!backtracking(0)!}, sólo asume que el sudoku está
resuelto. 2. \passthrough{\lstinline!read\_sudoku!} asume que recibirá
81 números en la entrada estándar, sin ningún tipo de corrección de
errores si encuentra EOF.

Afortunadamente, añadir mejor reporte de errores no debería ser muy
difícil.

Lo que sí podría ser un poco más de trabajo sería hacer que el algoritmo
averiguara el número de soluciones posibles para un tablero determinado.
Habría que cambiar la firma de \passthrough{\lstinline!backtracking!} y
sumar todos los casos posibles, lo cual significaría analizarlos todos
por lo que la potencia del computador podría llegar a ser un limitante.

\newpage

\hypertarget{anexo-cuxf3digo}{%
\section{Anexo: Código Completo}\label{anexo-cuxf3digo}}

El código está en inglés porque el lenguaje también lo está, y usar
siempre el mismo idioma reduce la carga cognitiva.

\_ \_

\begin{lstlisting}[language=Java, basicstyle=\tiny]
import java.util.Scanner;

class Main {
    static int board[][] = new int[9][9]; // first coordinate is row, second is column
    static boolean discarded[][][] = new boolean[9][9][10]; // always skip the first one

    public static void main(String[] args) {
        get_sudoku();
        int filled_before_backtracking = 0;
        while (true) {
            discard_when_possible();
            int just_filled = fill_cells();
            if (just_filled == 0) {
                break;
            }
            filled_before_backtracking += just_filled;
        }
        backtracking(0);
        print_sudoku();
        System.out.println(filled_before_backtracking);
    }

    static void discard_when_possible () {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                int num = board[i][j];
                if (num != 0 && !discarded[i][j][num]) { // don't repeat work
                    discard_column(i, j, num);
                    discard_row(i, j, num);
                    discard_block(i, j, num);
                }
            }
        }
    }

    static void discard_row(int row, int column, int num) {
        for (int i = 0; i < 9; i++) {
            discarded[row][i][num] = true;
        }
    }

    static void discard_column(int row, int column, int num) {
        for (int i = 0; i < 9; i++) {
            discarded[i][column][num] = true;
        }
    }

    static void discard_block(int row, int column, int num) {
        // I only care about the start of the blocks
        row = row - row%3;
        column = column - column%3;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                discarded[row+i][column+j][num] = true;
            }
        }
    }

    static int fill_cells() {
        int filled = 0;
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == 0) {
                    if (replace_if_possible(i, j)) {
                        filled++;
                    }
                }
            }
        }
        return filled;
    }

    // checks if the spot has only one possible answer left
    // in that case, sets the spot to that answer and returns true
    // otherwise, returns false
    static boolean replace_if_possible(int row, int column) {
        int candidate = 0; // silence "might now have been initialized" error
        boolean found_candidate = false;
        for (int i = 1; i <= 9; i++) {
           if (!discarded[row][column][i] && found_candidate) {
               return false;
           } else if (!discarded[row][column][i]) {
               candidate = i;
               found_candidate = true;
           }
        }
        if (!found_candidate) {
            System.out.println("there was a problem");
            System.exit(1);
        }
        board[row][column] = candidate;
        return true;
    }

    static void get_sudoku() {
        Scanner sc = new Scanner(System.in);

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                board[i][j] = sc.nextInt();
            }
        }
        sc.close();
    }

    static void print_sudoku() {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                System.out.printf("%d ", board[i][j]);
            }
            System.out.println();
        }
    }

    static boolean backtracking(int cur_index) {
        // first, find a cell to try to fill
        // each call to the function will be in charge of one cell
        while (cur_index < 9*9) {
            int row = cur_index/9;
            int column = cur_index%9;
            if (board[row][column] != 0) {
                cur_index++;
                continue;
            }
            for (int i = 1; i <= 9; i++) {
                if (discarded[row][column][i]) {
                    continue;
                }
                board[row][column] = i;
                if (check(row, column) && backtracking(cur_index+1)) {
                    return true;
                }
            }
            board[row][column] = 0;
            return false;
        }

        // couldn't find an empty cell => finished
        return true;
    }

    static boolean check(int row, int column) {
        int num = board[row][column];

        // check the row
        for (int i = 0; i < 9; i++) {
            if (board[row][i] == num) {
                if (i != column) {
                    return false;
                }
            }
        }

        // check the column
        for (int i = 0; i < 9; i++) {
            if (board[i][column] == num) {
                if (i != row) {
                    return false;
                }
            }
        }

        // check the block
        int base_row = row - row%3;
        int base_column = column - column%3;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[base_row+i][base_column+j] == num) {
                    if (base_row+i != row || base_column+j != column) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
\end{lstlisting}

\end{document}
